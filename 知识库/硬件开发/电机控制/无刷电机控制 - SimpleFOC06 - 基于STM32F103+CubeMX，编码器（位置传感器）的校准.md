# 导言
---
上一章节《[[无刷电机控制 - SimpleFOC05 - 基于STM32F103+CubeMX，实现速度开环控制]]》完成三相无刷电机的开环速度控制。接下来，开始调试编码器（位置传感器）。为接下来的位置闭环控制，速度闭环控制做准备。

### RTT_Viewer
![[Pasted image 20250108184226.png]]

### 编码器校准的动作
![[飞书20250108-121114.mp4]]

# 一、校准编码器的目的
---
![[Pasted image 20250107211108.png]]
**校准编码器的目的是确定编码器的方向direction与计算出偏移角度offset。** 编码器输出的方向可能与电机的旋转方向不一致，它们之间的方向关系是1或者-1。校准方向一次只需要进行一次，同一个电机与编码器只需要校准一次，后续就可以写死在程序里。编码器安装在电机轴上时，可能由于安装的角度误差，导致编码器与电机转子之间产生固定的角度偏移，它就是偏移角offset。理论上来说，这个偏移角等于0。每一个电机与编码器的组合都要校准一遍，因为每一个的安装公差都不一样。校准之后，可以将偏移角保存在Flash里，程序初始化时，从flash里读取出来。

# 二、代码
---
## 2.1、user_main.cpp
![[Pasted image 20250108184328.png]]
如上图所示，增加三句代码后，运行代码`motor_initFOC()`的时候会执行编码器的校准，最终的到编码器方向CCW与编码器偏移角2.0264。
![[Pasted image 20250108165547.png]]
如上所示，编译代码成功，下载到开发板即可。

# 三、细节补充
---
## 3.1、motor.initFOC()执行编码器校准的流程
![[Pasted image 20250108170442.png]]
![[Pasted image 20250108171806.png]]
![[Pasted image 20250108172147.png]]
如上所示，simpleFOC校准编码器的代码真的很简单。

## 3.2、为什么计算偏移角时，需要将磁场方向固定在电角度_3PI_2（270°）？
**便于实现一个稳定的转子位置**。在 FOC 控制中，转子的稳定位置依赖于定子产生的磁场方向。如果施加的电角度为_3PI_2，实际上是将电机定子的磁场指向一个固定方向。
1. 电角度270°是一个常用的选择，因为这个角度会使得转子受到定子磁场的吸引，最终停留在唯一确定的位置。
2. 为什么选择固定方向：校准的关键是将转子停在一个已知的位置，以便读取编码器的机械角度。因此，任何固定且有效的电角度都可以实现这一目标,电角度_3PI_2 是其中一种常用的选择。

**电角度270°有如下优点**：
1. 对应于三相电压波形，设Ua、Ub、Uc三相电压，电角度270度时通常会产生一种对称且平衡的三相电流波形。
2. 在三相电压空间矢量调制（SVPWM）中，电角度270度常被用作对齐的基准点，避免了更复杂的电压矢量计算。
3. 电角度0度或360度通常对应于特定相电压完全导通的情况，可能导致电机电流不平衡或抖动。而电角度270度通常位于电压波形的较平滑区域，更容易生成稳定的磁场，避免转子不必要的振动。

## 3.3、转子的机械角度与电角度的关系
**电角度 = 极对数p x 机械角度。** 极对数7的无刷电机的电角度范围是(0° ～ 360° x 7) = 0° ~ 2520°。如果只有 1 对极：扫过一次 N-S，电角度就转了 360°；机械上也转了 360°。如果有 7 对极：转子转一圈机械角度（360°），定子却感受到 7 次 N-S 的完整通过 → 电角度=7×360°=2520°。

**电角度的用途：**
1. Park/Clarke 变换：把三相电流转换到旋转坐标系(d-q轴)，需要知道电角度来确定坐标轴的旋转位置。
2. 无刷换相：无刷直流电机(BLDC)在进行六步换相或正弦驱动时，需要实时知道当前转子的电角度，以切换或调制合适的绕组励磁。
3. 
**机械角度的用途：**
1. 位置或速度控制：如果要让电机旋转到某个机械位置(比如 90°)，我们用机械角度来参考。
2. 外部运动系统的坐标：如机械臂、轮子等，都关注物理位置。

## 3.4、为什么FOCMotor::electricalAngle()的输出被限制在 0 ~ 2π？
```C++
float FOCMotor::electricalAngle(){
  // if no sensor linked return previous value ( for open loop )
  if(!sensor) return electrical_angle;
  return  _normalizeAngle( (float)(sensor_direction * pole_pairs) * sensor->getMechanicalAngle()  - zero_electric_angle );
}
```
`FOCMotor::electricalAngle()`输出的是当前的电角度，那么电角度 = 极对数p x 机械角度。为什么函数里使用函数_normalizeAngle()将电角度归一化到0 ~ 2π?

**FOC控制算法只需要“相位”，0 ~ 2π区间内足矣。** 在电机控制算法（尤其是 FOC）中，我们关心的“电角度”其实是一个在正弦/余弦空间里“周期为 360°（或 2π）”的相位角。只要知道当前电角度在 0 ~ 2π 范围内（或 0 ~ 360°），就能计算正、余弦进行坐标变换（Park / Clarke 变换）或换相等。换言之，电角度多绕几圈（例如 2520° 对应 7 圈）和只取余数 (0~360° 这一圈) 对正余弦计算结果是一样的。例如，正弦波Sin(θ)在0或0+2kπ(k是整数)时，计算的结果是一样的。*如果应用场景需要跟踪转过多少圈，可以在机械角度或传感器圈计数的层面上去做，而不是在“电角度”输出里进行。*

**避免数值溢出或精度问题。** 如果让电角度不断累加，很可能越转越大，数值最终会溢出 float/int 的范围或变得难以管理。用作实时控制时，各种算法、观察器、滤波器、状态机都通常假定角度在0 ~ 2π或者-π ～ π之间。
例如，若让电角度保持累加到 2520°（极对数7）、5040°（极对数14）……乃至更大，会给各种运算、比较、滤波带来麻烦。


