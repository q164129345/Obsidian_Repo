# 导言
---
![[Pasted image 20250114112908.png | 1100]]
**FOC的精髓是电流环，但并不是没有电流环就没办法用FOC。** 如上所示，simpleFOC在没有电流环前提下的位置闭环控制框架。此时，闭环的关键是电机的编码器。效果如下所示，电机总是能回到设置的目标位置。

![[20250114-114914.mp4]]

## RTT_Viewer
![[ctrl1.gif]]
**位置闭环的本质是程序一直在检查目标位置与当前位置的距离（也叫位置差），距离越大，转矩分量Ud越大，距离接近0时，转矩分量Ud也接近0**。如上图所示，程序初始化时先校准传感器，获取编码器的方向与0电角度（找到电角度与转子角度之间的固定关系）。程序设定了目标角度是1.0f。在上面视频里，我用手摆动电机的转子，让它离开1.0f的位置。当我的手松开后，位置闭环会让转子重新回到1.0f的位置。这就是位置闭环。

项目源码：https://github.com/q164129345/MCU_Develop/tree/main/simplefoc07_stm32f103_position_close
# 一、代码
---
## 1.1、user_main.cpp
![[Pasted image 20250114165751.png | 1100]]
![[Pasted image 20250114172441.png | 1100]]
![[Pasted image 20250114173250.png | 1100]]

## 1.2、梳理源码BLDCMotor::loopFOC()
![[Pasted image 20250114195451.png | 1100]]
BLDCMotor::loopFOC()与BLDCMotor::move()都是simpleFOC的核心代码，且需要高频运行。
![[Pasted image 20250114200114.png | 1100]]
![[Pasted image 20250114200340.png | 1100]]
总的来说，在没有电流环的时候，loopFOC()主要做了以下：
1. 获取实时的编码器位置信息，并更新时间戳。
2. 根据新的编码器位置信息，更新电角度θ。
3. 根据转矩分量Uq与励磁分量Ud，电角度θ来进行反帕克、SVPWM运算，最终输出Ua、Ub、Uc占空比。

## 1.3、梳理源码BLDCMotor::move()
![[Pasted image 20250114204041.png | 1100]]
![[Pasted image 20250114204609.png | 1100]]
![[Pasted image 20250114204706.png | 1100]]
总的来说，在没有电流环的时候，move()主要做了以下：
1. 更新转子的位置、速度（给PID控制器使用）。
2. 根据模式，执行PID运算后的转矩分量Uq与Ud。


# 二、细节补充
---
## 2.1、三相占空比波形
![[Pasted image 20250114173842.png | 1100]]
如上所示，当目标位置1.0f=现在位置1.0f时，转矩分量Ud接近0，此时三相Ua、Ub、Uc的占空比约等于0.5，就是三相电压几乎相等。

![[Uabc.gif | 1100]]
如上图所示，目标位置=1.0f，当我用手去摆动电机的转子时（从右边RTT的反馈看到，当前位置不在1.0f）。三相Ua、Ub、Uc产生马鞍波，试图让电机回到1.0f的目标位置。

## 2.2、每2S让控制的位置增加1.0f
**代码：**
![[Pasted image 20250115180344.png | 1100]]
**RTT_Viewer:**
![[Pasted image 20250115180311.png | 1100]]
**实际效果：**
![[20250115-180522.mp4]]



