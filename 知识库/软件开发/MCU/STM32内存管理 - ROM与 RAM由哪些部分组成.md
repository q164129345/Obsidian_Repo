## 导言

---
理解RAM和Flash的管理，以及各个内存段的细节，对于嵌入式系统开发尤其重要，原因包括但不限于以下几点：
**1. 资源优化**
- 嵌入式系统通常在硬件资源上有限制，特别是内存资源。准确理解不同内存段的特点可以帮助开发者高效地使用这些资源，避免浪费，并在有限的空间内实现更多的功能。
**2. 性能提升**
- 正确地分配和管理内存资源可以提升程序的运行效率。例如，将频繁访问的数据存放在快速访问的内存区域可以减少访问延迟，提高程序响应速度。
**3. 可靠性和稳定性**
- 理解内存管理有助于避免常见的内存问题，如堆栈溢出、内存泄露、非法访问等，这些问题可能导致程序崩溃或不稳定的行为。
**4. 低功耗设计**
- 在许多嵌入式应用中，低功耗是一个重要目标。了解如何合理利用RAM和ROM，以及如何通过优化内存使用减少CPU的功耗，对于设计低功耗设备至关重要。
**5. 安全性**
- 内存管理不当可能导致安全漏洞，比如缓冲区溢出可被利用执行任意代码。了解内存段和内存保护机制可以帮助实现更安全的系统设计。
**6. 调试和维护**
- 在软件调试和维护过程中，理解程序的内存使用情况是诊断问题的关键。这包括分析内存溢出、内存泄露或程序异常行为的根本原因。
**7. 多任务和操作系统支持**
- 对于运行实时操作系统（RTOS）的嵌入式系统，合理的内存分配和管理对于实现任务间的有效切换、资源共享和通信机制非常重要。
总之，了解RAM和ROM的管理以及各个内存段的细节，不仅有助于提升程序的性能和可靠性，同时对于资源优化、低功耗设计、系统安全以及有效的调试和维护等方面都至关重要。这些知识使得开发者能够更好地控制和优化其嵌入式系统，满足特定应用的需求。
## 一、通过.map文件了解编译后程序的内存分配
---
![[Pasted image 20240816114750.png]]
STM32程序顺利编译成功后，通过.map文件能知道Flash与RAM需要多少空间。如上图所示，Flash的空间需要占用34.82kb，RAM空间需要占用4.25kb。

RAM跟FLASH究竟由什么组成？RW Data段是什么？ZI Data段是什么？为什么RW Data段参与了RAM的大小计算，又参与Flash的大小计算？

## 二、RAM（random access memory）

---
![[Pasted image 20240816114838.png]]
STM32的RAM内存由4部分组成（STM32的RAM规定从**`0x20000000`**开始，假如RAM的大小是64KB，那RAM的地址从**`0x20000000`** ~ **`0x2000FFFF`**）：

**栈（Stack）**
- 用于存储局部变量、函数参数、返回地址等。
- 具有后进先出（LIFO）的特性。
- 自动管理，随着函数调用和返回动态增长和缩减。
- 从RAM的顶部**`0x2000FFFF`**向下增长。栈的起始大小和位置可以在启动代码或链接脚本中定义。

**堆（Heap）**
- 用于动态内存分配，如通过**`malloc`**、**`free`**等函数管理。
- 程序运行时根据需要动态分配和释放。
- 大小和位置通常在链接时定义，运行时由动态内存管理器管理。
- 从某个预定的地址向上增长，这里假设是从**`0x20002000`**开始。堆的实际起始地址取决于堆管理策略和其他数据段的大小。

**ZI数据段（Zero Initialized Data） - 又叫.bss段(Block Started by Symbol)**
- 存储未初始化的全局变量和静态变量，或显式初始化为零的变量。
- 在程序启动时自动清零。
- 不占用Flash空间，因为它们在编译时不需要分配初始值。
- 位于堆之下，这里假设占据从**`0x20001000`**到**`0x20002000`**的范围。

**RW数据段（Read-Write Data）- 又叫.data段**
- 存储已初始化的全局变量和静态变量的初始值。
- 程序启动时，这些初始值从Flash复制到RAM中。
- 同时占用Flash（用于存储初始值）和RAM（运行时使用）。
- 存放初始化的全局和静态变量，位于ZI数据段下方，这里从RAM的底部**`0x20000000`**开始，直到ZI段的起始地址。

### 2.1、将变量定义在RW data段（.data段）
![[Pasted image 20240816115047.png]]
![[Pasted image 20240816115104.png]]
如上图所示，定义一个全局变量g_test并初始化为7。通过.map文件看到，它在.data段。


### 2.2、将变量定义在ZI data段（.bss段）
![[Pasted image 20240816115229.png]]
![[Pasted image 20240816115250.png]]
如上图所示，定义一个全局变量g_test并初始化零。通过.map文件看到，它在.bss段。可以继续自行测试一下不初始化全局变量g_test时，它是不是被安排在.bss段。

PS：我测试了一下，确认是在.bss段。
## 三、ROM（read only memory）

---
![[Pasted image 20240816114948.png]]

**中断向量表**
- 从Flash的底部**`0x08000000`**开始。其大小取决于中断数量和系统配置，这里假设其大小约为**`0x100`**（256字节）。

**启动代码**
- 紧随中断向量表之后，负责初始化硬件、设置栈指针于**`0x08001000`**。

**常量数据**
- 存放不变的数据，如字符串字面量等，这里从**`0x08001000`**开始，假设到**`0x08020000`**（约192KB）。

**已初始化的全局/静态变量（RW data段）**
- 占据一段空间，从**`0x08020000`**开始，这里假设有**`0x10000`**（约64KB）的数据。

请注意，上述地址和大小仅为示例，实际应用中需根据实际情况进行调整。特别是程序代码、常量数据和已初始化变量的实际大小将根据具体的应用程序而有很大差异。另外，Flash的剩余部分可以用于存储其他类型的数据，比如查找表、文件系统或程序升级的备份区域等。在开发过程中，可以通过链接脚本（Linker Script）来精细控制各个段的位置和大小，以优化内存的使用。

## 四、Q&A（常见问题）

---

### 4.1、为什么RAM要分ZI data段与RW data段

- **效率**：将变量按是否需要初始化的初始值分类，可以提高程序的效率。对于RW Data，需要从Flash到RAM的复制操作，以保证程序运行时这些变量具有正确的初始值。而ZI Data则不需要这样的复制操作，仅在RAM中分配空间并统一清零，简化了程序启动过程。
- **节省空间**：通过避免在Flash中存储大量默认为零的数据，可以更有效地使用有限的存储资源。这对于资源受限的嵌入式系统尤为重要。

### 4.1、为什么RW data段同时占用ROM跟RAM？？
![[Pasted image 20240816115330.png]]
```c
uint32_t g_test = 7;  // 被安排到RW data段（.data段）,既占用RAM又占用ROM。
```

原因比较好理解，因为7需要被保存起来（需要掉电保存，所以在ROM），在初始化g_test的时候使用。

既然.data段的变量既占用ROM又占用RAM，这个段应该越小越好。对此，我们应该：

**1、节省存储空间**

- **`.data`**段的变量在程序编译后存储在Flash中，并在程序启动时复制到RAM中。因此，这些变量既占用Flash空间，也占用RAM空间。减小**`.data`**段的大小可以帮助节省这两种存储资源，特别是对于RAM资源非常有限的系统。

**2、加快启动时间**

- 在系统启动时，需要将**`.data`**段的内容从Flash复制到RAM中。**`.data`**段越大，这个过程所需的时间就越长。因此，减小**`.data`**段的大小有助于减少系统启动时间，加快系统响应。

**3、提高运行效率**

- 对于需要频繁访问的数据，将其存放在RAM中可以提高访问速度。但是，无节制地增加RAM的使用量会导致可用的RAM资源减少，从而影响其他需要动态内存分配的功能（如堆分配）。通过优化**`.data`**段的大小，可以更有效地利用RAM资源，保证系统的高效运行。

**优化策略**

为了减小**`.data`**段的大小，可以采取以下一些策略：

- **限制全局变量的使用**：只有当全局变量确实需要在多个函数间共享时才使用，否则考虑使用局部变量。
- **优化数据初始化**：对于可以延迟初始化或程序运行中计算得到的数据，避免在声明时赋予初始值。
- **使用`const`关键字**：对于不会改变的数据，使用**`const`**关键字声明，这样的数据通常会被放置在**`.rodata`**（只读数据）段，该段仅占用Flash空间，不占用RAM。
- **复用变量**：在不同的程序阶段复用变量，以减少同时需要的全局变量数量。

总之，通过对**`.data`**段的大小进行优化，可以在保持程序功能的同时，提高资源利用率和系统性能。在嵌入式系统开发中，这种优化是非常重要的一部分。