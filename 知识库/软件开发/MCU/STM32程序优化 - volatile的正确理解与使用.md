## 导言
---
有一句话广泛地在网络上流传：“是否理解volatile是区分一般软件工程师与嵌入式工程的一个标准”。
volatile的意思是“易变的”。

**`volatile`关键字在C语言中有什么作用？为什么需要使用它？**
**`volatile`** 关键字在 C 语言中的作用主要是告知编译器，定义为 **`volatile`** 的变量可以在任何时刻被意外地改变，因此编译器在处理这类变量时不应该应用常规的优化策略。这意味着每次访问 **`volatile`** 变量时，程序都需要直接从其内存地址读取数据，而不是使用可能存储在寄存器中的缓存值。
总的来说，就是告诉编译器被修饰为volatile的变量，必须每一次都从内存里拿数据，千万不能忽略内存，而只从寄存器里拿数据（有可能编译器从内存只拿了一次数据，后面全是从寄存器拿了，当内存的值变化了，主程序却不知道）。

## 一、volatile的使用场景
---
**`volatile`的使用场景如下：**

1. **硬件访问**：在嵌入式系统中，硬件设备的状态可能由硬件自身独立于程序的控制而变化（例如，通过设备的寄存器）。使用 **`volatile`** 确保程序每次都会从其硬件寄存器而非缓存中读取最新状态。
2. **中断服务例程**：在中断服务例程（ISR）中经常使用 **`volatile`**，因为变量可能在 ISR 中被改变，而主程序需要访问这些最新的值。如果变量不是 **`volatile`**，编译器可能会优化掉某些看似无用的加载或存储操作，从而导致主程序无法获取到在 ISR 中更新的值。
3. **多线程应用**：在多线程环境下，一个线程中的变量（全局变量）可能被另一个线程修改，使用 **`volatile`** 可以避免因编译器优化而导致的数据不一致问题。

总之，**`volatile`** 关键字是一种类型修饰符，用于防止编译器对代码进行某些优化，确保程序能够直接从内存地址中访问变量值。这对于确保程序逻辑的正确性，尤其是在多任务环境和直接硬件操作时非常关键。

所以，编写大型RTOS程序必须要掌握volatile的使用，不然会出现这种神奇现象。

<aside> 💡 出现神奇现象时，关掉编译器优化试试，会不会有奇效？？

</aside>

## 二、编译器为什么要优化？优化的策略是什么？哪些跟voltatile有关系？
---
**为什么编译器需要干优化的事情？提升程序的性能减少代码的体积！！**

**编译器优化策略（简单了解一下）**

- 1. 死代码消除
    这种优化策略用于移除那些从未被执行的代码，例如在编译后明显无法到达的代码块。
- 2. 循环优化
    包括循环展开（用来减少循环中的条件判断次数）、循环融合（合并多个相似的连续循环以减少开销）和循环不变代码外提（将循环中不变的部分计算移至循环外部执行）等技术。
- 3. 内联展开
    将函数调用替换为函数体本身的代码，这样可以消除函数调用的开销，但可能增加程序的总体大小。
- 4. 常量折叠和传播
    编译时计算常量表达式的结果，并将其传播到使用这些常量的位置，以减少运行时的计算量。
- 5. 公共子表达式消除
    识别并消除在代码中多次计算但结果不变的表达式，以避免重复计算。
- 6. 条件传播
    基于确定的条件表达式，提前计算和简化表达式。
- 7. 强度削减
    用较低开销的操作替换较高开销的操作。例如，将乘法替换为移位操作。
- 8. 尾调用优化
    在函数末尾的函数调用可以被优化以减少调用开销，有时可以转换为跳转指令。
- 9. 寄存器分配
    尽量使用寄存器存储变量而非内存，因为寄存器的访问速度远快于内存。
- 10. 代码重排
    重新排列代码指令的顺序以避免流水线阻塞和优化指令缓存的使用效率。
- 11. 指令级并行
    利用现代处理器的能力，对可以并行执行的指令进行重排，以提高执行效率。

编译器优化的主要挑战在于保持优化后代码的功能与未优化前相同，同时尽可能提升性能或降低资源消耗。编译器通常提供不同级别的优化设置，开发者可以根据具体需要选择适当的优化级别。这些设置可能会在保证代码执行正确性和优化代码性能之间进行权衡。

**其中，跟volatile有关系的优化如下：**
1. 死代码消除
    如果某段代码只对一个标记为**`volatile`**的变量进行读写操作，编译器可能会认为这些操作没有其他影响而考虑将其优化掉。但由于**`volatile`**的存在，编译器必须保留这些看似无用的读写操作，因为它们可能对程序状态有重要影响，尤其是在硬件访问和多线程环境中。
    
2. 公共子表达式删除
    编译器通常会查找并优化在多个地方计算但结果相同的表达式。然而，如果这些表达式涉及**`volatile`**变量，即使表达式看起来相同，它们的结果也可能因为外部改变而不同，因此编译器不能对其进行优化。
    
3. 常量折叠与传播
    对于涉及**`volatile`**变量的操作，即使其值在编译时已知，编译器也不能将其折叠为常量或者将其值传播到其他地方，因为每次访问**`volatile`**变量都必须直接从其内存地址获取，以确保获取到最新值。
    
4. 条件传播
    当涉及到**`volatile`**变量的条件表达式时，编译器不能根据当前的分析结果预先决定代码的执行路径，因为**`volatile`**变量的值可能随时被外部因素改变。
    
5. 优化相关代码重排
    编译器在对程序进行优化时，可能会调整指令的执行顺序以提高效率。然而，如果这些指令涉及**`volatile`**变量，编译器必须保持原有的访问顺序，以确保程序的行为符合预期，特别是在与硬件直接交互时。
    
这些优化策略中的限制强调了为什么开发者需要准确理解和使用**`volatile`**关键字。正确的使用可以防止编译器做出可能导致程序运行异常的优化决策。这对于编写可靠的系统级软件尤其重要，尤其是在需要与硬件设备交互或在多线程环境中确保数据同步的场景中。

## 三、实际应用
---
### 3.1、在嵌入式系统中，为什么经常在访问硬件寄存器时使用**`volatile`**声明？

在嵌入式系统中，硬件寄存器通常用来控制或监控与CPU相连的硬件设备的状态。这些寄存器的值可能会由硬件在任何时候独立于软件控制进行改变，或者写入到这些寄存器的操作可能会触发硬件的特定行为。因此，使用**`volatile`**关键字声明对硬件寄存器的访问是至关重要的，以确保软件正确、可靠地与硬件交互。下面是一些具体的例子和解释：

1、读取状态寄存器：
```bash
volatile uint8_t* status_reg = (uint8_t*) 0x40001000; // 假定的状态寄存器地址
```

在这种情况下，设备可能在任何时候更新状态寄存器。如果**`status_reg`**不是被声明为**`volatile`**，编译器可能认为该寄存器的值在没有明显修改的情况下保持不变，从而可能优化掉对该寄存器的多次读取。这会导致软件错过硬件状态的更新。

既然是读取状态寄存器，增加const，禁止修改指针所指向的变量会更合适一些：
```bash
volatile uint8_t* const status_reg = (uint8_t*) 0x40001000; // 假定的状态寄存器地址
```

2、写入控制寄存器：
```bash
volatile uint8_t* control_reg = (uint8_t*) 0x40001010; // 假定的控制寄存器地址
```

在这个例子中，向**`control_reg`**写入一个值可能启动一个模数转换(ADC)。如果**`control_reg`**没有被声明为**`volatile`**，编译器可能认为多次写入相同的值是不必要的，并优化掉除第一次之外的所有写入操作。这将阻止后续的ADC操作被触发。

3、实时数据寄存器
```bash
volatile uint8_t* temp_reg = (uint8_t*) 0x40001020; // 假定的温度寄存器地址
```
在这种情况下，温度值可能在任何时间点更新。如果**`temp_reg`**不被声明为**`volatile`**，编译器可能会将首次读取的值缓存起来重复使用，从而导致程序使用过时的数据。

### 3.2、如果有一个整型变量被多个中断服务例程和主程序访问，为什么该变量应声明为volatile？
假设在一个嵌入式系统中，有一个整型变量**`count`**被用来记录系统中发生的特定事件的次数。这个事件可能由多种不同的硬件触发，因此存在多个中断源，每个中断源都有自己的中断服务例程。同时，主程序需要读取这个**`count`**变量以决定是否采取某些行动。
```c
volatile int count = 0;  // 全局变量声明为volatile

void ISR_for_Sensor1(void) {
    count++;  // 由传感器1触发的中断
}

void ISR_for_Sensor2(void) {
    count++;  // 由传感器2触发的中断
}

void main(void) {
    while(1) {
        if (count >= 10) {
            // 执行某些操作
            count = 0;  // 重置计数器
        }
    }
}
```

**为什么需要`volatile`？**
1. **保证内存访问**：由于**`count`**变量可被多个中断服务例程和主程序修改和读取，**`volatile`**关键字确保每次访问**`count`**时都是直接从内存读取，而不是从CPU寄存器或者其他缓存中读取。这防止了编译器做出可能忽略硬件修改的优化决策。
2. **防止编译器优化**：没有**`volatile`**关键字，编译器可能认为在主循环中的判断**`if (count >= 10)`**是不必要的，因为在它的优化逻辑看来，在循环内部**`count`**变量的值没有改变。这可能导致编译器优化掉这一判断或者整个循环内的读取操作，从而导致程序逻辑错误。
3. **数据一致性**：**`volatile`**关键字确保所有中断服务例程和主程序中对**`count`**的修改都能立即反映出来，保持数据的一致性和实时更新。

通过使用**`volatile`**关键字，可以确保程序逻辑的正确性和可预测性，尤其是在多中断源和并发执行的环境中。这对于确保嵌入式系统的响应性和稳定性至关重要。

### 3.3、多线程环境中使用volatile和不使用volatile时可能出现的问题
在多线程环境中，**`volatile`**关键字的使用与否对程序的行为有着显著影响，特别是涉及到多个线程共享和修改同一个变量时。下面通过一个具体的例子来展示使用和不使用**`volatile`**可能带来的不同后果。

**示例场景**
假设有一个简单的程序，其中包含两个线程。一个线程负责增加一个共享变量**`flag`**的值，另一个线程监控这个变量的值并在**`flag`**变为非零时执行某些操作。

```c
int flag = 0;  // 共享变量，未声明为volatile
void thread1() {
    // 等待一些操作完成
    sleep(1);  // 模拟操作延时
    flag = 1;  // 设置flag为1
}
void thread2() {
    while (flag == 0) {
        // 循环直到flag不为0
    }
    // 执行一些响应flag的操作
    printf("Flag is set!\\n");
}
int main() {
    start_thread(thread1);
    start_thread(thread2);
    join_threads();
    return 0;
}

```

**不使用`volatile`**
- **问题描述**：在不使用**`volatile`**的情况下，编译器可能认为由于**`thread2`**内部没有修改**`flag`**，因此**`flag`**的值在循环期间不会改变。这可能导致编译器优化掉对**`flag`**的内存读取操作，使得**`thread2`**中的循环变成一个无限循环，因为**`thread2`**始终看不到**`flag`**值的改变。
- **结果**：程序可能陷入死锁，**`thread2`**永远无法跳出循环，因此无法执行打印操作或任何其他响应**`flag`**变化的逻辑。

**使用`volatile`**
- **代码修改**：
    ```c
    volatile int flag = 0;  // 使用volatile声明
    ```
- **期望行为**：通过将**`flag`**声明为**`volatile`**，编译器被告知这个变量可能会在程序的控制外被其他线程修改。因此，编译器将生成额外的指令，确保每次使用**`flag`**时都直接从内存读取其值，而不是使用缓存在寄存器中的可能过时的值。
- **结果**：**`thread2`**能够观察到**`flag`**的改变，一旦**`thread1`**修改了**`flag`**，**`thread2`**中的循环将终止，并执行后续操作。
### **结论**
在多线程环境中，正确使用**`volatile`**关键字对于确保线程之间正确的通信和变量的可见性至关重要。它防止了编译器在不了解多线程动态的情况下过度优化代码，从而避免了因变量更新不一致导致的程序错误和不可预测的行为。
## Q & A
---
### Q & A - 解释volatile关键字如何影响编译器的优化过程。
**`volatile`**关键字在C语言中的主要作用是影响编译器的优化策略，确保对特定变量的操作不会被编译器在优化过程中改变、移除或简化。当一个变量被声明为**`volatile`**时，编译器必须对这个变量的每次读写都直接进行，严格按照源代码中的指示执行，不能使用寄存器或其他缓存中的值代替直接访问内存。

**影响编译器优化的具体方式包括：**

1. **阻止寄存器优化**：通常，为了提高效率，编译器会尝试将变量存储在寄存器中，而不是每次都从内存中读取或写入。但如果变量声明为**`volatile`**，则编译器必须在每次程序请求时，从变量的内存地址直接读取或写入该变量的值，因此该变量不会被缓存在寄存器中。
2. **保持代码顺序**：编译器经常会重新排列指令顺序以填充流水线或优化其他性能参数。对于涉及**`volatile`**变量的操作，编译器必须保持源代码中指定的顺序执行，以确保所有的副作用按预期发生，尤其是在多线程或硬件交互的情况下。
3. **禁止优化掉看似无用的操作**：如果一个操作只涉及到**`volatile`**变量，即使这个操作的结果似乎未被使用，编译器也不能优化掉这个操作。这是因为**`volatile`**变量的读取或写入可能有重要的副作用，例如，触发硬件行为或与外部设备的通信。
4. **禁止公共子表达式消除**：如果一个表达式涉及**`volatile`**变量并且被多次使用，编译器通常可能只计算一次并重用结果。但是，如果变量是**`volatile`**的，编译器必须每次都重新计算该表达式，因为变量的值可能在每次访问之间发生变化。

**为什么这些影响很重要：**

这些特性对于编写硬件驱动程序、操作系统内核和并行程序至关重要。例如，操作系统的内核可能需要使用**`volatile`**来读取和写入硬件的状态寄存器，确保对硬件寄存器的操作按预期发生，且状态是最新的。同样，在多线程程序中，某些变量可能在没有适当的同步原语保护的情况下被多个线程访问，**`volatile`**保证了变量的读取和写入是直接与内存交互的。

总结来说，**`volatile`**关键字告诉编译器，涉及到的变量可以在程序的控制之外被修改，因此它通过禁止或调整某些优化来确保程序的正确性和预期行为。这有助于开发者编写与外部系统交互的可靠且高效的代码。