# 导言
---
`std::unique_ptr` 和 `std::shared_ptr` 都是 C++ 中的智能指针，目的是自动管理动态内存，防止手动管理内存时的错误（如内存泄漏）。然而，它们的工作方式和适用场景有明显区别。下面详细讨论它们的差异及使用场景。

# 一、std::unique_ptr
**独占所有权：** `std::unique_ptr` 独占指向对象的所有权，也就是说同一时间只有一个 `unique_ptr` 能指向某个对象。
**不能复制：** `std::unique_ptr` 不允许复制，只能通过**移动语义**（move semantics）将所有权从一个 `unique_ptr` 转移给另一个。
**更轻量：** 因为它不需要维护引用计数，所以开销比 `shared_ptr` 小。

**使用场景：**
当你确定某个资源只会有一个所有者，且没有共享资源的需求时，使用 `unique_ptr` 是最佳选择。典型应用场景包括：
1. 管理文件句柄、网络连接等独占资源。
2. 管理大数据结构的局部对象生命周期，避免内存泄漏。

**代码示例**
```cpp
#include <iostream>
#include <memory>

void foo() {
    std::unique_ptr<int> p1 = std::make_unique<int>(10); // 创建一个 unique_ptr

    // std::unique_ptr 不允许复制
    // std::unique_ptr<int> p2 = p1;  // 错误：不能复制unique_ptr

    // 但可以转移所有权
    std::unique_ptr<int> p2 = std::move(p1);  // p2 现在拥有对象，p1 变为空
    std::cout << "p2: " << *p2 << std::endl;
}

```
**适用场景：**
1. 独占资源，如文件、数据库连接或单例对象。
2. 当对象的生命周期只存在于某个函数或局部区域，且不需要共享对象。

# 二、std::shared_ptr
---
**共享所有权：** `std::shared_ptr` 允许多个指针共享同一个对象。当最后一个指针超出作用域时，内存会自动释放。
**引用计数：** 每个 `shared_ptr` 会维护一个引用计数，记录有多少个指针引用该对象。每当一个新的 `shared_ptr` 复制或赋值时，引用计数增加；当 `shared_ptr` 离开作用域时，引用计数减少。引用计数归零时，对象会被自动销毁。
**开销较大：** 由于需要维护引用计数，`shared_ptr` 的内存开销和性能开销通常比 `unique_ptr` 大。

**使用场景**
当多个对象需要共享同一个资源，且资源的生命周期由所有使用者共同决定时，`shared_ptr` 是合适的选择。
典型应用场景包括：
1.在多线程或多组件系统中共享数据或对象。
2.在某些复杂的面向对象设计中，实现对象之间的共享关系。

**代码示例**
```cpp
#include <iostream>
#include <memory>

void foo() {
    std::shared_ptr<int> p1 = std::make_shared<int>(10);  // 创建一个 shared_ptr
    std::shared_ptr<int> p2 = p1;  // p2 和 p1 共享同一个对象

    std::cout << "p1: " << *p1 << ", p2: " << *p2 << std::endl;
    std::cout << "Reference count: " << p1.use_count() << std::endl;  // 引用计数为 2
}

```
**适用场景：**
1. 共享资源，如在不同模块、类或线程中共享同一资源。
2. 适用于那些对象生命周期复杂、无法由单一所有者管理的场景。

# 三、关键区别
---
|特性|std::unique_ptr|std::shared_ptr|
|---|---|---|
|**所有权**|独占所有权，只能通过移动语义转移所有权|共享所有权，多方共同管理对象生命周期|
|**复制**|不可复制（只能移动）|可以复制（引用计数加1）|
|**开销**|开销较小（不需要引用计数）|开销较大（需要维护引用计数）|
|**生命周期管理**|生命周期由单一所有者管理|生命周期由所有共享者共同管理|
|**多线程**|不适合多个线程共享同一对象|适合多个线程共享对象|
|**典型使用场景**|独占资源，如文件句柄、局部对象|共享资源，如多个模块间共享的数据结构|

# 四、何时使用哪一个？
---
**使用 `std::unique_ptr` 的场景：**
- 当你希望对象的生命周期明确，由单一所有者管理时。
- 当你不需要多个指针共享该对象的所有权时。
- 需要更高效的内存管理，减少额外的引用计数管理开销。
**使用 `std::shared_ptr` 的场景：**
- 当对象需要在多个地方共享时，比如不同的类、函数或线程都需要使用同一个对象。
- 当你不能明确地知道某个对象何时被销毁，且希望由多个共享者共同管理该对象的生命周期。